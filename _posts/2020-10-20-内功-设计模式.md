---
layout: post
title: 设计模式
catalog: true
tags:
    - 内功
---
# 一.设计模式要依赖的原则

## 1.1依赖倒转原则

面向接口编程

例子：

![1591509947096](https://gitee.com/chrisxyq/picgo/raw/master/img/1591509947096.png)

修改：通过接口实现对类的依赖

![1591510231071](https://gitee.com/chrisxyq/picgo/raw/master/img/1591510231071.png)

## 1.2里式替换原则

子类应尽量少的重写父类的方法，可通过依赖的方式使用父类的方法

## 1.3开闭原则



开闭原则：使用抽象类

![1591512420179](https://gitee.com/chrisxyq/picgo/raw/master/img/1591512420179.png)

## 1.4迪米特法则

最小知道原则

## 1.5合成复用原则

如果只是使用另一个类的方法：使用依赖、聚合和组合

# 二.类之间的关系



依赖组合和聚合

![1591513014307](https://gitee.com/chrisxyq/picgo/raw/master/img/1591513014307.png)

![1591514091855](https://gitee.com/chrisxyq/picgo/raw/master/img/1591514091855.png)

# 三.设计模式

## 3.1单例模式

### 3.1.1饿汉式静态变量/静态代码块

![1591515113960](https://gitee.com/chrisxyq/picgo/raw/master/img/1591515113960.png)

![1591515429924](https://gitee.com/chrisxyq/picgo/raw/master/img/1591515429924.png)



### 3.1.2线程不安全/安全懒汉式

![1591515691323](https://gitee.com/chrisxyq/picgo/raw/master/img/1591515691323.png)

![1591515813373](https://gitee.com/chrisxyq/picgo/raw/master/img/1591515813373.png)

![1591515878560](https://gitee.com/chrisxyq/picgo/raw/master/img/1591515878560.png)

### 3.1.3推荐使用的效率高的懒汉式

![1591516341896](https://gitee.com/chrisxyq/picgo/raw/master/img/1591516341896.png)

### 3.1.4推荐静态内部类的懒汉式

![1591516566816](https://gitee.com/chrisxyq/picgo/raw/master/img/1591516566816.png)

静态内部类在类装载时不会被装载，当静态方法调用时，装载

### 3.1.5推荐枚举实现

![1591516791534](https://gitee.com/chrisxyq/picgo/raw/master/img/1591516791534.png)

### 3.1.6举例和应用场景

JDK的Runntime就是饿汉式的单例模式

![1591517091894](https://gitee.com/chrisxyq/picgo/raw/master/img/1591517091894.png)

## 3.2工厂模式

### 3.2.1工厂方法模式



![1591519491389](https://gitee.com/chrisxyq/picgo/raw/master/img/1591519491389.png)

把核心构造方法抽象化

![1591519738466](E:\Java_learning\学习笔记\1.jpg)

简单工厂：就一层工厂类，且把方法写到工厂里

工厂方法：两层工厂类，把方法写到各个子工厂里

### 3.2.2抽象工厂模式

工厂方法是抽象方法

抽象工厂是接口

![1591520360885](https://gitee.com/chrisxyq/picgo/raw/master/img/1591520360885.png)

![1591520480786](https://gitee.com/chrisxyq/picgo/raw/master/img/1591520480786.png)

![1591520585552](https://gitee.com/chrisxyq/picgo/raw/master/img/1591520585552.png)



### 3.2.2举例和应用场景

Calender类就是用简单工厂模式

## 3.3原型模式

spring bean的创建

![1591521505754](https://gitee.com/chrisxyq/picgo/raw/master/img/1591521505754.png)





# 6.设计模式

## 6.1单例模式

书：大话设计模式

![1590589839032](https://gitee.com/chrisxyq/picgo/raw/master/img/1590589839032.png)

饿汉式实现

![1590590097402](https://gitee.com/chrisxyq/picgo/raw/master/img/1590590097402.png)

懒汉式实现

![1590590385826](https://gitee.com/chrisxyq/picgo/raw/master/img/1590590385826.png)

效率高又线程安全的懒汉式

![1596812424455](https://gitee.com/chrisxyq/picgo/raw/master/img/1596812424455.png)

区分饿汉式和懒汉式

- 从线程安全角度：饿汉式天然是线程安全的，目前的写法懒汉式线程不安全。
- 从创建对象角度：饿汉式的对象加载时间过长，而懒汉式好处在于延迟对象的创建。
- 笔试时写线程安全的饿汉式。

应用场景

![1590592353096](https://gitee.com/chrisxyq/picgo/raw/master/img/1590592353096.png)

## 6.2模板方法的设计模式

抽象类的应用：模板方法的设计模式

![1590644923190](https://gitee.com/chrisxyq/picgo/raw/master/img/1590644923190.png)

![1590644981658](https://gitee.com/chrisxyq/picgo/raw/master/img/1590644981658.png)

![1590645098940](https://gitee.com/chrisxyq/picgo/raw/master/img/1590645098940.png)

模板方法的设计模式的应用场景

![1595771218907](https://gitee.com/chrisxyq/picgo/raw/master/img/1595771218907.png)



## 6.3代理模式

接口的应用：代理模式

反射实现动态代理

![1590649022340](https://gitee.com/chrisxyq/picgo/raw/master/img/1590649022340.png)

代理模式举例：中介找房子、明星与经纪人

新建一个代理类的对象，并将被代理类的对象作为形参传进代理类的构造器

![1590649215509](https://gitee.com/chrisxyq/picgo/raw/master/img/1590649215509.png)

![1590649359153](https://gitee.com/chrisxyq/picgo/raw/master/img/1590649359153.png)

![1590649376577](https://gitee.com/chrisxyq/picgo/raw/master/img/1590649376577.png)



![1590649306344](https://gitee.com/chrisxyq/picgo/raw/master/img/1590649306344.png)

## 6.4工厂模式

没有使用工厂模式时候：对象创建与方法的调用是混在一起的

接口的应用：工厂模式

工厂方法模式

![1595774276921](https://gitee.com/chrisxyq/picgo/raw/master/img/1595774276921.png)

注：可通过反射来进一步改进工厂方法模式

抽象工厂模式与工厂方法模式的区别就在于创建对象的复杂程度上

# 12.反射

使用javabean空参构造器构造对象

封装性解决的是建议怎么调用的问题

反射解决的是能不能调用的问题

反射：当编译时候不能确定造哪个类的对象，使用反射。如后台运行时，接收不同的url请求，造不同的对象。

反射的源头：java.lang.Class类的对象

注意：要创建一个Class的实例，不能new Class，Class的实例应该是运行时类。如

调用运行时类的属性

Class clazz=Person.class

![1596208632495](https://gitee.com/chrisxyq/picgo/raw/master/img/1596208632495.png)

## 12.1获取Class实例

获取Class实例是实现反射的第一步，有四种方法获取Class实例

![1596254286946](https://gitee.com/chrisxyq/picgo/raw/master/img/1596254286946.png)



## 12.2通过classloader加载配置文件

![1596258489168](https://gitee.com/chrisxyq/picgo/raw/master/img/1596258489168.png)



## 12.2创建运行时类的对象

反射是体现语言动态性的关键

使用Class类的forname(全类名)的方法创建运行时类

使用运行时类的newInstance方法创建运行时类的对象

![1596269326406](https://gitee.com/chrisxyq/picgo/raw/master/img/1596269326406.png)



## 12.3调用运行时类的对象的指定属性/方法

getDeclaredField()

![1596270119751](https://gitee.com/chrisxyq/picgo/raw/master/img/1596270119751.png)

调用运行时类的对象的非静态方法

Class clazz=Person.class；

![1596270558829](https://gitee.com/chrisxyq/picgo/raw/master/img/1596270558829.png)

调用运行时类的对象的静态方法：任意对象均可

![1596270859641](https://gitee.com/chrisxyq/picgo/raw/master/img/1596270859641.png)

# 13.动态代理

AOP:动态代理

静态代理和动态代理的区别是：代理本身是编译时确定还是运行时动态创建的

静态代理：代理类和被代理类在编译期间就确定下来，且都实现同一个接口

静态代理是将被代理类的对象作为代理类的属性

![1596273882196](https://gitee.com/chrisxyq/picgo/raw/master/img/1596273882196.png)

动态代理是根据被代理类创建代理类

![1596273925187](https://gitee.com/chrisxyq/picgo/raw/master/img/1596273925187.png)

![1596271024199](https://gitee.com/chrisxyq/picgo/raw/master/img/1596271024199.png)



