---
layout: post
title: JUC
catalog: true
tags:
    - 内功
---
视频来源：https://www.bilibili.com/video/BV1Kw411Z7dF

# 1.多线程

1.1进程线程

进程：正在执行的程序，是资源调度的基本单位、每个进程有独立的内存区域（方法区和堆空间）

线程：一个程序内部的一条执行路径，每个线程有独立的虚拟机栈和程序计数器，一个进程的多个线程共享同一个堆和方法区、因此若一个进程有一个实例变量，多个线程都可进行访问修改、jvm调优即为对线程共享的区域（堆进行优化

相较于进程，同一进程的线程之间通信的方便之处，类似于合租室友访问同一个厨房进行交流

![image-20210117224738752](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210117224738752.png)



## 7.1线程的方法和优先级

![1596788027094](https://gitee.com/chrisxyq/picgo/raw/master/img/1596788027094.png)

注：yield方法释放当前线程的执行权，但有可能再次获得执行权

![1596787943764](https://gitee.com/chrisxyq/picgo/raw/master/img/1596787943764.png)

同一个进程的线程共享方法区和堆，每个线程有独立的虚拟机栈和程序计数器

子类中抛的异常不能比父类的大，父类没有抛异常，则子类重写的方法也不能抛异常。只能用try catch。

## 7.2创建线程的四种方法

### 7.2.1继承Thread类

![1590735086663](https://gitee.com/chrisxyq/picgo/raw/master/img/1590735086663.png)

使用示例

![image-20210117225724261](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210117225724261.png)

匿名子类

![image-20210117230423014](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210117230423014.png)

三个窗口卖票问题：如下实现有线程安全问题，即有重票/错票现象

![image-20210117232330012](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210117232330012.png)

若不想使用static，采用实现runnable接口的方式

### 7.2.2实现Runnable接口

![1590735045476](https://gitee.com/chrisxyq/picgo/raw/master/img/1590735045476.png)

多窗口卖票示例

![1596790885120](https://gitee.com/chrisxyq/picgo/raw/master/img/1596790885120.png)

![1596790827293](https://gitee.com/chrisxyq/picgo/raw/master/img/1596790827293.png)

- window这个对象就是多个线程共享的数据，相较于继承的方式，ticket不用加static

- Thread类本身也是实现runnable接口的



### 7.2.3实现Callable接口

JDK5.0新特性的两种方法

![image-20210118001502562](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118001502562.png)

![image-20210118001706204](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118001706204.png)

使用示例

![image-20210118002842558](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118002842558.png)

![image-20210118002641713](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118002641713.png)

注：

futuretask的构造器需要传入一个实现callable接口的对象，即numthread

futuretask实现了runnable接口，因此可以作为构造器的参数传入thread类，以启动一个新的线程

futuretask和callable接口都支持泛型，以指定返回数据的类型

### 7.2.4使用线程池

![1590761700714](https://gitee.com/chrisxyq/picgo/raw/master/img/1590761700714.png)

![image-20210118000825613](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118000825613.png)

使用示例

![image-20210118001253869](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118001253869.png)



## 7.4线程的五种状态/生命周期和线程通信

Thread的内部类State定义了线程的几种状态

![1596791611715](https://gitee.com/chrisxyq/picgo/raw/master/img/1596791611715.png)

![1596798231562](https://gitee.com/chrisxyq/picgo/raw/master/img/1596798231562.png)

- 运行到就绪：通过yield()暂时失去cpu的执行权，可能下一秒又获得执行权

- 阻塞到就绪：notify()唤醒当前的wait()阻塞状态的线程

- 运行到阻塞：wait()使得线程进入阻塞状态并且释放锁，sleep()使得线程进入阻塞状态但不会释放锁
- wait/notify、suspend/resume

![1590752697844](https://gitee.com/chrisxyq/picgo/raw/master/img/1590752697844.png)

![1590752867761](https://gitee.com/chrisxyq/picgo/raw/master/img/1590752867761.png)

## 7.3解决线程安全的方法

重票/错票示意

![image-20210117235242040](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210117235242040.png)

### 7.3.1线程同步：synchronized+同步监视器/锁

![1590739017314](https://gitee.com/chrisxyq/picgo/raw/master/img/1590739017314.png)

解决线程安全的方法是：线程同步

当线程同步锁发生嵌套的时候：可能发生死锁

方式1：使用同步代码块，需要显式的指定唯一的锁

方式2：使用同步方法，不需要显示指定锁，默认将this当前对象作为锁

继承thread类创建的线程，使用同步方法进行同步，需要将同步方法定义为static，且共享数据也应是static

实现runnable接口创建的线程，使用同步方法进行同步，不需要将同步方法定义为static，且共享数据不需要是static

### 7.3.2线程同步：Lock

JDK5.0提供了Lock锁的方式实现同步



![1596813967867](https://gitee.com/chrisxyq/picgo/raw/master/img/1596813967867.png)

![1596814033948](https://gitee.com/chrisxyq/picgo/raw/master/img/1596814033948.png)

![1596814077209](https://gitee.com/chrisxyq/picgo/raw/master/img/1596814077209.png)

### 7.3.3线程同步：synchronized和Lock的区别

首选lock，由于lock是5.0新增的，且更灵活

其次用同步代码块，因为同步代码块在方法体内部才分配相应的资源

最后才考虑用同步方法。

![1596814458536](https://gitee.com/chrisxyq/picgo/raw/master/img/1596814458536.png)

![1590747022340](https://gitee.com/chrisxyq/picgo/raw/master/img/1590747022340.png)

## 7.5线程死锁示例

一人一只筷子

![1596812920164](https://gitee.com/chrisxyq/picgo/raw/master/img/1596812920164.png)

![1596812990231](https://gitee.com/chrisxyq/picgo/raw/master/img/1596812990231.png)

在两个锁之间加上sleep，以增大死锁概率

![1596813075985](https://gitee.com/chrisxyq/picgo/raw/master/img/1596813075985.png)

1.wait和sleep的区别

![1601466686292](https://gitee.com/chrisxyq/picgo/raw/master/img/1601466686292.png)

2.lock接口

三个实现类

可重入锁

读锁

写锁