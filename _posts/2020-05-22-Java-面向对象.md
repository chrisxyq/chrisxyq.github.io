---
layout: post
title: 面向对象
catalog: true
tags:
    - Java
---
# 4.面向对象

## 4.1 封装

封装性的体现：对属性或者方法的权限修饰

![image-20210110215735431](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210110215735431.png)



## 4.2 继承

继承是多态的前提

封装性：解决的是可不可见的问题；继承性：能不能拿到的问题

![image-20210110215806788](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210110215806788.png)

![image-20210110215923118](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210110215923118.png)

![image-20210110220019781](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210110220019781.png)

## 4.3 重写

1.重写的可见性权限修饰符不能更小，类似摊煎饼果子覆盖

2.父类的private的方法不能被重写、static的方法也不能被重写

## 4.4 多态

![image-20210110220042048](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210110220042048.png)

对象的多态性：父类的引用指向子类的对象

编译时候认为是person、运行时候认为是man、因此将重写的方式称为运行时多态

如果没有多态性，只能在父类中去写重载的方法

有了多态性就省去了重载的方法，可以在父类中将方法的形参声明为一个抽象的类型如object，然后调用方法的时候传入子类的对象

举例

![image-20210110220058470](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210110220058470.png)

建立多种数据库连接

建立mysql连接，具体调用mysql重写的方法

注意：多态性只适用于方法不适用于属性

证明多态是运行时行为：使用随机数作为flag

只要不是动态绑定就不是多态，即重写不是多态

![image-20210110220112250](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210110220112250.png)

## 4.5属性与局部变量的区别

声明位置不同，属性直接声明在类的{}里面

局部变量不允许使用权限修饰符，其权限由方法确定

属性不需要初始化值，局部变量需要

非static属性加载到堆空间，局部变量加载到栈空间





